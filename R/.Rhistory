help(optim)
sp <- log10(c(2,16,60,361,2064))
newdata <- expand.grid(psi=c(1:5),
form=c(2,4,6),
sp=sp)
train <- data.frame(newdata,
runtime=log10(
c(0.805,2.78,6.063,9.764,14.95,9.501,17.027,29.555,39.689,
43.487,17.749,27.518,47.987,67.399,72.414,5.939,20.242,
49.263,76.991,121.885,87.128,142.669,238.165,331.573,
380.358,137.593,219.523,397.072,565.97,611.179,22.047,
74.614,178.325,278.9,437.789,247.234,417.854,728.54,
1041.818,1251.531,390.871,700.187,1228.689,1810.935,
1984.01,98.144,322.868,692.772,1079.517,1670.174,942.015,
1505.443,2662.768,3821.902,4500.767,1414.023,2382.089,
4320.619,6293.292,6870.837,321.706,1134.647,2711.463,
4157.906,6675.549,4577.276,7227.623,12797.01,18742.85,
20641.35,6907.341,11416.35,20945.35,30983.38,33640.44)/60))
intercepts <- c()
slopes <- c()
for (i in sp){
m <- lm(runtime ~ log(I(psi+form)), data=subset(train, subset=sp==i))
intercepts <- c(intercepts, coef(m)[1])
slopes <- c(slopes, coef(m)[2])
}
pred <- lm(formula = intercepts ~ sp)
summary(pred)
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline,
runtime=coef(pred)[1]+mean(slopes)*log(psi+form))
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
summary(psi)
summary(try)
n.form = 6
n.form = 3
n.psi=4
n.sp=2064
n.form=6
n.psi=5
testset <- data.frame(form=n.form, psi=n.psi)
runtime <- predict(try, newdata = testset,
interval="confidence", type="response") + coef(pred)[2]*log10(n.sp)
plot(train$psi+train$form, train$runtime)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
View(train)
10^2.7
10^2.7*60
10^2.7487*60
runtime
points(n.form+n.psi, runtime[1], shp=15, color="grey40")
points(n.form+n.psi, runtime[1], shp=15, col="grey40")
points(n.form+n.psi, runtime[1], pch=15, col="grey40")
help(pch)
suppressWarnings(points(n.form+n.psi, runtime[1], pch=8, col="grey40"))
plot(sp, intercepts)
pred <- nls(y~a/(1 + exp(-b * (x-c))), start=list(a=1,b=.5,c=25))
pred <- nls(intercepts~a/(1 + exp(-b * (sp-c))), start=list(a=1,b=.5,c=25))
pred <- nls( intercepts ~ a * sp^b / ( c + s^b ) , start = list ( a =0.2, b =50, c=1))
intercepts
sp
pred <- nls( intercepts ~ a * sp^b / ( c + s^b ) , start = list ( a =0.2, b =1, c=1))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =0.2, b =1, c=1))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =0.2, b =3, c=1))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =-0.2, b =3, c=1))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =-0.2, b =3, c=-3))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =-3, b =2, c=1))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =-3, b =2, c=-1))
pred <- nls( intercepts ~ a * sp^b / ( c + sp^b ) , start = list ( a =-3, b =2, c=0))
pred <- nls( intercepts ~ a / ( 1 + exp(b*(sp-c))) , start = list ( a =-3, b =2, c=0))
pred <- nls( intercepts ~ a / ( 1 + exp(b*(sp-c))) , start = list ( a =-3, b =-2, c=0))
pred <- nls(intercepts ~ SSlogis(log(sp), Asym, xmid, scal))
help(nls)
pred <- nls(intercepts ~ SSlogis(sp, Asym, xmid, scal))
help(SSlogis)
pred <- nls(intercepts ~ a * sp ^ (1/3) - b, start = list(a=1, b=0))
pred
predict(pred)
points(sp, predict(pred))
points(sp, predict(pred), col="red")
pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
points(sp, predict(pred), col="blue")
pred <- lm(formula = intercepts ~ sp)
points(sp, predict(pred), col="green")
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline,
runtime=coef(pred)[1]+mean(slopes)*log(psi+form))
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
testset <- data.frame(form=n.form, psi=n.psi)
runtime <- predict(try, newdata = testset,
interval="confidence", type="response") + coef(pred)[2]*log10(n.sp)
runtime
#plot(sp, intercepts)
pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
coef(pred)
pred <- lm(formula = intercepts ~ sp)
coef(pred)
#plot(sp, intercepts)
pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
yint <- coef(pred)[1]*(0+coef(pred)[2])^(1/3) - coef(pred)[3]
yint
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline,
runtime=yint+mean(slopes)*log(psi+form))
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
testset <- data.frame(form=n.form, psi=n.psi)
predict(pred)
help(predict)
baseline
testset
predict(pred, newdata=data.frame(sp=0))
shift <- predict(pred, newdata=data.frame(sp=log10(n.sp)))
shift
0.8769074 * log10(n.sp)
shift <- predict(pred, newdata=data.frame(sp=log10(n.sp)))-yint
shift
runtime <- predict(try, newdata = testset,
interval="confidence", type="response") + shift
runtime
#plot(sp, intercepts)
pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) + c*sp - d, start = list(a=1, b=0, c=0, d=0))
#plot(sp, intercepts)
pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) + c*sp - d, start = list(a=1, b=0, c=0.1, d=0))
#plot(sp, intercepts)
pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
yint <- predict(pred, newdata=data.frame(sp=0))
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline,
runtime=yint+mean(slopes)*log(psi+form))
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
testset <- data.frame(form=n.form, psi=n.psi)
shift <- predict(pred, newdata=data.frame(sp=log10(n.sp)))-yint
runtime <- predict(try, newdata = testset,
interval="confidence", type="response") + shift
runtime
pred <- nls(intercepts ~ a/(1 + exp(-b * (sp-c))), start=list(a=1,b=.5,c=25))
pred <- nls(intercepts ~ a/(1 + exp(-b * (sp-c))), start=list(a=0,b=.5,c=1))
pred <- nls(intercepts ~ a/(1 + exp(-b * (sp-c))), start=list(a=-1,b=.5,c=1))
pred <- nls(intercepts ~ a/(1 + exp(-b * (sp-c))), start=list(a=-1,b=.005,c=1))
pred <- nls(intercepts ~ a/(1 + exp(-b * (sp))), start=list(a=-1,b=.005))
points(sp, predict(pred), col="hotpink")
##  pred <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
##pred <- lm(formula = intercepts ~ sp)
yint <- predict(pred, newdata=data.frame(sp=0))
yint
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline,
runtime=yint+mean(slopes)*log(psi+form))
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
testset <- data.frame(form=n.form, psi=n.psi)
shift <- predict(pred, newdata=data.frame(sp=log10(n.sp)))-yint
shift
runtime <- predict(try, newdata = testset,
interval="confidence", type="response") + shift
runtime
#plot(sp, intercepts)
pred <- nls(intercepts ~ a/(1 + exp(-b * (sp+c))), start=list(a=-1,b=.005,c=0))
#plot(sp, intercepts)
pred1 <- nls(intercepts ~ a/(1 + exp(-b * (sp))), start=list(a=-1,b=.005))
pred2 <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
##pred <- lm(formula = intercepts ~ sp)
yint <- mean(predict(pred1, newdata=data.frame(sp=0)),predict(pred2, newdata=data.frame(sp=0)))
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
yint
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline,
runtime=yint+mean(slopes)*log(psi+form))
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
testset <- data.frame(form=n.form, psi=n.psi)
predict(pred1, newdata=data.frame(sp=log10(n.sp)))-yint
predict(pred2, newdata=data.frame(sp=log10(n.sp)))-yint
shift <- mean(predict(pred1, newdata=data.frame(sp=log10(n.sp))),predict(pred2, newdata=data.frame(sp=log10(n.sp))))-yint
shift
predict(pred1, newdata=data.frame(sp=log10(n.sp)))
predict(pred2, newdata=data.frame(sp=log10(n.sp)))
yint
predict(pred1, newdata=data.frame(sp=0))
predict(pred2, newdata=data.frame(sp=0))
##pred <- lm(formula = intercepts ~ sp)
yint <- mean(predict(pred1, newdata=data.frame(sp=0)),predict(pred2, newdata=data.frame(sp=0)))
yint
##pred <- lm(formula = intercepts ~ sp)
yint <- (predict(pred1, newdata=data.frame(sp=0))+predict(pred2, newdata=data.frame(sp=0)))/2
yint
shift <- (predict(pred1, newdata=data.frame(sp=log10(n.sp)))+predict(pred2, newdata=data.frame(sp=log10(n.sp))))/2-yint
shift
runtime <- predict(try, newdata = testset,
interval="confidence", type="response") + shift
runtime
10^runtime[1]
10^runtime[1]*60
10^2.81*60
10^2.81
anova(pred1, pred2)
pred3 <- lm(formula = intercepts ~ sp)
anova(pred1, pred3)
anova(pred3, pred2)
summary(pred1)
BIC(pred1)
BID(pred2)
BIC(pred2)
anova(pred3, pred1)
anova(pred3, pred2)
pred0 <- lm(formula = intercepts ~ sp)
## define candidate models
#pred0 <- lm(formula = intercepts ~ sp)
pred1 <- nls(intercepts ~ a/(1 + exp(-b * (sp))), start=list(a=-1,b=.005))
pred2 <- nls(intercepts ~ a * (sp + b) ^ (1/3) - c, start = list(a=1, b=0, c=0))
anova(pred0, pred1) # very different
pred0 <- lm(intercepts ~ sp)
anova(pred0, pred1) # very different
anova(pred0, pred1, pred2) # very different
pred0
pred1
## define candidate models
pred0 <- nls(intercepts ~ a*sp +b, start=list(a=-1,b=.005) )
pred0
anova(pred0, pred1) # very different
anova(pred0, pred2)
anova(pred1, pred2)
## define candidate models
pred0 <- nls(intercepts ~ a*log(sp) + b, start=list(a=-1,b=.005))
points(sp, predict(pred0), col="cyan")
## Calculate weighted average of the models
delta <- BIC(pred1) - BIC(pred2)
delta
## Calculate weighted average of the models
delta <- BIC(pred2) - BIC(pred1)
weight1 <- exp(-0.5 * delta) / (1 + exp(-0.5 * delta))
weight2 <- 1 - weight1
BIC(pred1)
BIC(pred2)
## use weights to calculate a weighted y-intercept
yint <- predict(pred1, newdata=data.frame(sp=0))*weight1+predict(pred2, newdata=data.frame(sp=0)))*weight2
## use weights to calculate a weighted y-intercept
yint <- predict(pred1, newdata=data.frame(sp=0))*weight1+predict(pred2, newdata=data.frame(sp=0))*weight2
yint
plot(sp, intercepts)
plot(sp, intercepts, pch=15)
points(sp, predict(pred1), col="green", pch=17)
points(sp, predict(pred2), col="blue", pch=17)
plot(sp, intercepts, pch=0)
plot(sp, intercepts, pch=0, size=2)
plot(sp, intercepts, pch=0, cex=2)
help(pch)
points(sp, predict(pred1), col="green", pch=2)
points(sp, predict(pred2), col="blue", pch=6)
plot(sp, intercepts, pch=0, cex=1.5)
points(sp, predict(pred1), col="green", pch=2)
points(sp, predict(pred1), col="red", pch=2)
points(sp, predict(pred2), col="blue", pch=6)
## use weights to calculate a weighted y-intercept and y-shift for the user n.sp parameter
yint <- predict(pred1, newdata=data.frame(sp=0))*weight1+predict(pred2, newdata=data.frame(sp=0))*weight2
shift <- predict(pred1, newdata=data.frame(sp=log10(n.sp)))*weight1+
predict(pred2, newdata=data.frame(sp=log10(n.sp)))*weight2-yint
## generate a baseline for n.sp=1 (log(n.sp)=0) from which to shift
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline, runtime=yint+mean(slopes)*log(psi+form))
## generate baseline model from baseline data
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
## this is the user input parameters
testset <- data.frame(form=n.form, psi=n.psi)
## predict runtime based on baseline model and n.sp-dependent y-shift
runtime <- predict(try, newdata = testset, interval="confidence", type="response") + shift
runtime
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
suppressWarnings(points(n.form+n.psi, runtime[1], pch=8, col="grey40"))
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
exp(sp)
10^(sp)
#plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
legend(0,1,legend=c("2"=1,"16"=2,"60"=3,"361"=4,"2064"=5), pch=20)
#plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
legend(10,1,legend=c("2"=1,"16"=2,"60"=3,"361"=4,"2064"=5), pch=20)
help(legend)
#plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
legend(10,1,legend=as.character(10^sp), col=1:5, pch=20)
#plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
legend("right",legend=as.character(10^sp), col=1:5, pch=20)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
legend("right",legend=as.character(10^sp), col=1:5, pch=20)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("right",legend=as.character(10^sp), col=1:5, pch=20)
legend("right", inset=c(-0.2,0), legend=as.character(10^sp), col=1:5, pch=20)
legend("right", inset=c(-0.2,0), legend=as.character(10^sp), col=1:5, pch=20, title="n Species")
legend("right", inset=c(-0.2,0), legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
par(xpd=T)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("right", inset=c(-0.2,0), legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
help(par)
par(xpd=T)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20, bty="L")
legend("right", inset=c(-0.2,0), legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20, bty="L")
legend("right", inset=c(-0.2,0), legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
par(xpd=T)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20, bty="L")
legend("right", inset=c(-0.2,0), legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
par(xpd=F)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("top", inset=c(-0.2,0), legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
legend("top", inset=c(-0.2,0), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("top", inset=c(0.5,0.2), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
legend("top", inset=c(0.5,1), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
legend("top", inset=c(0.5,0.5), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
legend("top", inset=c(0.5,0), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
legend("top", inset=c(0.5,-0.2), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
par(xpd=T)
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("top", inset=c(0.5,-0.2), horiz=T, legend=rev(as.character(10^sp)), col=5:1, pch=20, title="n Species")
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("top", inset=c(0.5,-0.4), horiz=T, legend=as.character(10^sp), col=1:5, pch=20, title="n Species")
help(curve)
curve(coef(m)[2] * log(x) + coef(m)[1])
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("top", inset=c(0.5,-0.4), horiz=T, legend=as.character(10^sp), col=1:5, pch=20, title="n Species")
curve(coef(m)[2] * log(x) + coef(m)[1], add=T)
curve(coef(m)[2] * log(x) + coef(m)[1], add=T, col=which(sp==i))
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
legend("top", inset=c(0.5,-0.4), horiz=T, legend=as.character(10^sp), col=1:5, pch=20, title="n Species")
## get y-intercepts and slopes from each curve in above plot
intercepts <- c()
slopes <- c()
for (i in sp){
m <- lm(runtime ~ log(I(psi+form)), data=subset(train, subset=sp==i))
intercepts <- c(intercepts, coef(m)[1])
slopes <- c(slopes, coef(m)[2])
curve(coef(m)[2] * log(x) + coef(m)[1], add=T, col=which(sp==i))
}
## see how the intercepts change with the number of species in the dataset
plot(sp, intercepts, pch=0, cex=1.5)
points(sp, predict(pred1), col="red", pch=2)
points(sp, predict(pred2), col="blue", pch=6)
legend("top", inset=c(0.5,-0.4), horiz=T, legend=c("Observed","Logistic","Cube root"),
col=c("black","red","blue"), pch=c(0,2,6), title="Predictions")
## see how the intercepts change with the number of species in the dataset
plot(sp, intercepts, pch=0, cex=1.5)
## add the predictions to the graph
points(sp, predict(pred1), col="red", pch=2)
points(sp, predict(pred2), col="blue", pch=6)
legend("top", inset=c(0.5,-0.4), horiz=T, legend=c("Observed","Logistic","Cube root"),
col=c("black","red","blue"), pch=c(0,2,6), title="Observed vs Predicted")
pred1
curve(coef(pred1)[1]/(1 + exp(-coef(pred1)[2] * (x))) , add=T, col="red")
curve(coef(pred2)[1] * (sp + coef(pred2)[2]) ^ (1/3) - coef(pred2)[3], add=T, col="blue")
curve(coef(pred2)[1] * (x + coef(pred2)[2]) ^ (1/3) - coef(pred2)[3], add=T, col="blue")
## see how the intercepts change with the number of species in the dataset
plot(sp, intercepts, pch=0, cex=1.5)
curve(coef(pred1)[1]/(1 + exp(-coef(pred1)[2] * (x))) , add=T, col="red")
curve(coef(pred2)[1] * (x + coef(pred2)[2]) ^ (1/3) - coef(pred2)[3], add=T, col="blue")
legend("top", inset=c(0.5,-0.4), horiz=T, legend=c("Observed","Logistic","Cube root"),
col=c("black","red","blue"), pch=c(0,2,6), title="Observed vs Predicted")
legend("top", inset=c(0.5,-0.4), horiz=T, legend=c("Observed","Logistic","Cube root"),
col=c("black","red","blue"), pch=c(0,2,6), lty=c(0,1,1), title="Observed vs Predicted")
legend("top", inset=c(0.5,-0.4), horiz=T, legend=c("Observed","Logistic","Cube root"),
col=c("black","red","blue"), pch=c(0,NA,NA), lty=c(0,1,1), title="Observed vs Predicted")
## add the predictions to the graph
#points(sp, predict(pred1), col="red", pch=2)
#points(sp, predict(pred2), col="blue", pch=6)
curve(coef(pred1)[1]/(1 + exp(-coef(pred1)[2] * (x))) , add=T, col="red", lwd=1.5)
curve(coef(pred2)[1] * (x + coef(pred2)[2]) ^ (1/3) - coef(pred2)[3], add=T, col="blue", lwd=1.5)
## add the predictions to the graph
#points(sp, predict(pred1), col="red", pch=2)
#points(sp, predict(pred2), col="blue", pch=6)
curve(coef(pred1)[1]/(1 + exp(-coef(pred1)[2] * (x))) , add=T, col="red", lwd=2)
curve(coef(pred2)[1] * (x + coef(pred2)[2]) ^ (1/3) - coef(pred2)[3], add=T, col="blue", lwd=2)
legend("top", inset=c(0.5,-0.4), horiz=T, legend=c("Observed","Logistic","Cube root"),
col=c("black","red","blue"), pch=c(0,NA,NA), lty=c(0,1,1), lwd=c(0,2,2), title="Observed vs Predicted")
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15))
plot(train$psi+train$form, train$runtime, col=rep(1:5, each=15), pch=20)
plot(train$psi+train$form, train$runtime, col="white", pch=20)
intercepts <- c()
slopes <- c()
for (i in sp){
m <- lm(runtime ~ log(I(psi+form)), data=subset(train, subset=sp==i))
intercepts <- c(intercepts, coef(m)[1])
slopes <- c(slopes, coef(m)[2])
curve(coef(m)[2] * log(x) + coef(m)[1], add=T, col=which(sp==i))
}
n.form=5
n.sp=1000
n.psi=3
## use weights to calculate a weighted y-intercept and y-shift for the user n.sp parameter
yint <- predict(pred1, newdata=data.frame(sp=0))*weight1+predict(pred2, newdata=data.frame(sp=0))*weight2
shift <- predict(pred1, newdata=data.frame(sp=log10(n.sp)))*weight1+
predict(pred2, newdata=data.frame(sp=log10(n.sp)))*weight2-yint
## generate a baseline for n.sp=1 (log(n.sp)=0) from which to shift
baseline <- expand.grid(psi=c(1:5),form=c(2,4,6),sp=0)
baseline <- dplyr::mutate(baseline, runtime=yint+mean(slopes)*log(psi+form))
## generate baseline model from baseline data
try <- lm(runtime ~ log(I(psi+form)), data=baseline)
## this is the user input parameters
testset <- data.frame(form=n.form, psi=n.psi)
## predict runtime based on baseline model and n.sp-dependent y-shift
runtime <- predict(try, newdata = testset, interval="confidence", type="response") + shift
points(n.form+n.psi, runtime[1], pch=8, col="grey40")
intercepts <- c()
slopes <- c()
for (i in sp){
m <- lm(runtime ~ log(I(psi+form)), data=subset(train, subset=sp==i))
intercepts <- c(intercepts, coef(m)[1])
slopes <- c(slopes, coef(m)[2])
curve(coef(m)[2] * log(x) + coef(m)[1], add=T, col=which(sp==i), lwd=2)
}
points(n.form+n.psi, runtime[1], pch=8, col="grey40")
points(n.form+n.psi, runtime[1], pch=20, col="black", cex=2)
points(n.form+n.psi, runtime[1], pch=18, col="black", cex=2)
legend("top", inset=c(0.5,-0.4), horiz=T, legend="Estimated runtime\nn.sp=1000, n.psi=3, n.form=5", col=1, pch=18, cex=2)
help(par)
legend("top", inset=c(0.5,-0.4), horiz=T, legend="Estimated runtime\nn.sp=1000, n.psi=3, n.form=5", col=1, pch=18, pt.cex=2)
plot(train$psi+train$form, train$runtime, col="white", pch=20)
intercepts <- c()
slopes <- c()
for (i in sp){
m <- lm(runtime ~ log(I(psi+form)), data=subset(train, subset=sp==i))
intercepts <- c(intercepts, coef(m)[1])
slopes <- c(slopes, coef(m)[2])
curve(coef(m)[2] * log(x) + coef(m)[1], add=T, col=which(sp==i), lwd=2)
}
points(n.form+n.psi, runtime[1], pch=18, col="black", cex=2)
legend("top", inset=c(0.5,-0.4), horiz=T, legend="Estimated runtime\nn.sp=1000, n.psi=3, n.form=5", col=1, pch=18, pt.cex=2)
## Convert estimated runtime to minutes
estimate <- 10^runtime[1]
